ᅠ长闩 廾闩, [07.11.2025 22:49]
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Подсистема управления памятью в ОС</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    body {
      margin: 0; padding: 0; font-family: 'Roboto', sans-serif; background: #0a1a2f; color: #fff;
    }
    .slide {
      width: 100vw; height: 100vh; display: flex; flex-direction: column;
      justify-content: center; align-items: center; padding: 40px; box-sizing: border-box;
      background: linear-gradient(135deg, #0a1a2f 0%, #1e3a5f 100%); position: relative;
      overflow: hidden; page-break-after: always;
    }
    .slide h1 { font-size: 3.5em; margin: 0; color: #00d4ff; text-shadow: 0 0 10px rgba(0,212,255,0.5); }
    .slide h2 { font-size: 2.2em; color: #ff8c00; margin: 20px 0; }
    .slide h3 { font-size: 1.8em; color: #ffd700; margin: 15px 0; }
    .slide p, .slide li { font-size: 1.3em; line-height: 1.6; margin: 8px 0; }
    .slide ul { width: 80%; max-width: 900px; }
    .slide img { max-width: 100%; max-height: 70vh; border-radius: 12px; box-shadow: 0 0 20px rgba(0,212,255,0.3); }
    .meme { max-width: 350px; border: 3px solid #ff8c00; border-radius: 12px; }
    .diagram { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; backdrop-filter: blur(5px); }
    .footer { position: absolute; bottom: 20px; right: 30px; font-size: 0.9em; color: #00d4ff; }
    .highlight { background: #ff8c00; color: #000; padding: 2px 8px; border-radius: 4px; }
    .bg-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.2; object-fit: cover; z-index: -1; }
    .center { text-align: center; }
    table { border-collapse: collapse; width: 80%; margin: 20px auto; }
    th, td { border: 1px solid #00d4ff; padding: 12px; text-align: center; }
    th { background: #1e3a5f; }
    .code { background: #000; color: #0f0; padding: 15px; border-radius: 8px; font-family: monospace; }
  </style>
</head>
<body>

<!-- СЛАЙД 1: Титульный -->
<div class="slide center">
  <img src="https://i.imgur.com/7z9kR1J.png" class="bg-img">
  <h1>Операционные системы</h1>
  <hr style="width: 200px; border: 1px solid #ff8c00;">
  <h2>#5 Подсистема управления памятью в операционной системе</h2>
</div>

<!-- СЛАЙД 2: Простые схемы -->
<div class="slide center">
  <img src="https://i.imgur.com/8kL2mNp.png" class="bg-img">
  <h1 style="color: #ff8c00;">ПРОСТЫЕ СХЕМЫ УПРАВЛЕНИЯ ПАМЯТЬЮ</h1>
  <img src="https://i.imgur.com/3vX9pQJ.png" style="max-width: 500px; margin-top: 20px;">
</div>

<!-- СЛАЙД 3: Иерархия памяти -->
<div class="slide">
  <img src="https://i.imgur.com/4pR7kLm.png" class="bg-img">
  <h2>ИЕРАРХИЯ ПАМЯТИ</h2>
  <p style="font-size: 1.5em; color: #ffd700;">Чем выше по рангу память к процессору, тем меньше время доступа, но и больше стоимость хранения.</p>
  <table>
    <tr><th>Уровень</th><th>Время доступа</th><th>Объём</th><th>Стоимость одного бита</th></tr>
    <tr><td>Регистры</td><td>Самое быстрое</td><td>Малый</td><td>Высокая</td></tr>
    <tr><td>Кэш</td><td>Быстро</td><td>Средний</td><td>Высокая</td></tr>
    <tr><td>Оперативная память</td><td>Среднее</td><td>Большой</td><td>Средняя</td></tr>
    <tr><td>Вторичная память</td><td>Медленно</td><td>Огромный</td><td>Низкая</td></tr>
  </table>
  <p><span class="highlight">Управляется менеджером памяти</span>: Оперативная память</p>
  <p><span class="highlight">Управляется ОС</span>: Вторичная память</p>
</div>

<!-- СЛАЙД 4: Принцип локальности -->
<div class="slide">
  <img src="https://i.imgur.com/5nG6hYj.png" class="bg-img">
  <h2>Принцип локальности</h2>
  <ul>
    <li>Большинство реальных программ в течение некоторого отрезка времени работает с <b>небольшим набором адресов памяти</b> – это <span class="highlight">принцип локальности</span>.</li>

ᅠ长闩 廾闩, [07.11.2025 22:49]
<li>Принцип локальности связан с <b>особенностями человеческого мышления</b>.</li>
    <li>Большинство реальных программ работает с <b>небольшим количеством переменных</b>.</li>
  </ul>
  <img src="https://i.imgur.com/6mK9pQz.png" class="meme">
</div>

<!-- СЛАЙД 5: Проблема разрешения адресов -->
<div class="slide">
  <img src="https://i.imgur.com/7oP8rTs.png" class="bg-img">
  <h2>Проблема разрешения адресов</h2>
  <ul>
    <li>Человеку свойственно <b>символическое мышление</b>. Адреса (имена) переменных описываются <b>идентификаторами</b>, формируя <span class="highlight">символьное адресное пространство</span>.</li>
    <li><b>Проблема перехода от символьной записи к адресной</b>.</li>
    <li>Оперативная физическая память может быть представлена в виде <b>массива ячеек с линейными адресами</b>.</li>
    <li><b>Совокупность всех доступных физических адресов</b> в вычислительной системе – это её <span class="highlight">физическое адресное пространство</span>.</li>
  </ul>
</div>

<!-- СЛАЙД 6: Этапы связывания -->
<div class="slide center">
  <img src="https://i.imgur.com/9qS2vWx.png" class="bg-img">
  <h2>Рассмотрим проблему связывания адресов с символьными идентификаторами</h2>
  <img src="https://i.imgur.com/1aB3cDe.png" style="max-width: 90%;">
</div>

<!-- СЛАЙД 7: Проблема связывания -->
<div class="slide">
  <img src="https://i.imgur.com/2dF4gHg.png" class="bg-img">
  <h2>Проблема связывания адресов</h2>
  <ul>
    <li><b>Этап компиляции</b>: сразу после выхода из компилятора все переменные имеют <b>окончательные адреса</b> для выполнения в физической памяти.</li>
    <li><b>Этап загрузки</b>: загрузчик может потенциально разместить переменные в <b>произвольных местах</b> физической памяти, но при этом двоичный образ <b>мигрировать не может</b>.</li>
    <li><b>Этап выполнения</b>: двоичный образ может <b>свободно перемещаться</b> по физической памяти.</li>
  </ul>
  <img src="https://i.imgur.com/3eG5iJk.png" class="meme">
</div>

<!-- СЛАЙД 8: Логическое АП -->
<div class="slide">
  <img src="https://i.imgur.com/4fH6kLm.png" class="bg-img">
  <h2>Логическое адресное пространство</h2>
  <ul>
    <li><b>Символьное адресное пространство</b> – совокупность всех допустимых <b>идентификаторов переменных</b>.</li>
    <li><b>Логическое адресное пространство</b> – совокупность всех допустимых <b>адресов</b>, с которыми работает процессор.</li>
    <li><b>Физическое адресное пространство</b> – совокупность всех доступных <b>физических адресов</b> в вычислительной системе.</li>
  </ul>
</div>

<!-- СЛАЙД 9: Функции ОС -->
<div class="slide">
  <img src="https://i.imgur.com/5gI7mNo.png" class="bg-img">
  <h2>Функции ОС и hardware</h2>
  <ul>
    <li>Отображение <b>логического адресного пространства процесса</b> на <b>физическое</b>.</li>
    <li>Распределение памяти между <b>конкурирующими процессами</b>.</li>
    <li><b>Контроль доступа</b> к адресным пространствам процессов.</li>
    <li><b>Выгрузка процессов</b> (целиком или частично) во внешнюю память.</li>
    <li><b>Учёт свободной и занятой памяти</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 10: Однопрограммная -->
<div class="slide center">
  <img src="https://i.imgur.com/6hJ8nPq.png" class="bg-img">
  <h2>Однопрограммная система</h2>
  <img src="https://i.imgur.com/7iK9oRs.png" style="max-width: 80%;">
  <p style="margin-top: 20px;">В этом случае ОС мы можем разместить в:</p>
  <ul style="text-align: left; width: 70%;">
    <li><b>младших адресах RAM</b>: программа живёт <b>после ОС</b></li>
    <li><b>старших адресах RAM</b>: процессы размещаются в <b>младших адресах</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 11: Фиксированные разделы -->
<div class="slide center">
  <img src="https://i.imgur.com/8jL0pTu.png" class="bg-img">
  <h2>Фиксированные разделы</h2>
  <img src="https://i.imgur.com/9kM1qVw.png" style="max-width: 85%;">
  <p style="margin-top: 15px;">Очереди для заданий формируются в зависимости от <b>требований к размерам RAM</b>.</p>
  <p>Однако программы могут требовать памяти <b>больше</b> чем размеры, а также <b>больше всей оперативной памяти</b>.</p>
</div>

ᅠ长闩 廾闩, [07.11.2025 22:49]
<!-- СЛАЙД 12: Организация больших программ -->
<div class="slide">
  <img src="https://i.imgur.com/0lN2rXy.png" class="bg-img">
  <h2>Организация больших программ</h2>
  <ul>
    <li><b>Оверлейная структура</b>
      <ul>
        <li>Программа разбивается на несколько частей. Постоянно в памяти находится <b>только загрузчик оверлеев</b>, небольшое количество общих данных и процедур, а части загружаются <b>по очереди</b>.</li>
      </ul>
    </li>
    <li><b>Динамическая загрузка процедур</b>
      <ul>
        <li>Процедуры загружаются в память <b>только по мере необходимости</b>, после обращения к ним.</li>
      </ul>
    </li>
    <li><b>Оба способа основаны на применении принципа локальности</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 13: Динамические разделы -->
<div class="slide center">
  <img src="https://i.imgur.com/1mO3sZA.png" class="bg-img">
  <h2>Динамические разделы</h2>
  <img src="https://i.imgur.com/2nP4tAB.png" style="max-width: 90%;">
</div>

<!-- СЛАЙД 14: Фрагментация -->
<div class="slide">
  <h2>Динамические разделы</h2>
  <p>Для борьбы с <b>фрагментацией памяти</b> может помочь <b>сборщик мусора</b>, который может провести <b>дефрагментацию RAM</b>. Однако он имеет ряд недостатков:</p>
  <ul>
    <li>Для передвижения процессов в RAM необходимо связывание адресов проводить <b>непосредственно на этапе выполнения</b>.</li>
    <li>При передвижении процессов, необходима <b>перенастройка таблиц процессов ОС</b>, что тоже требует затрат процессорного времени.</li>
  </ul>
</div>

<!-- СЛАЙД 15: Связывание на этапе выполнения -->
<div class="slide center">
  <h2>Связывание на этапе выполнения (БУП / MMU)</h2>
  <div class="code">
    Логический адрес → [Сегментный регистр] + [Логический адрес] → Физический адрес
  </div>
  <img src="https://i.imgur.com/3oQ5uCD.png" style="max-width: 80%; margin-top: 20px;">
</div>

<!-- СЛАЙД 16: Сегментная организация -->
<div class="slide">
  <h2>КУСОЧНО-НЕПРЕРЫВНОЕ ОТОБРАЖЕНИЕ</h2>
  <h3>Сегментная организация памяти</h3>
  <ul>
    <li>Логическое адресное пространство <b>не является непрерывным</b>, а разбивается на <b>сегменты</b>.</li>
    <li>Адрес становится <b>двумерным</b>: <code>(Nseg, offset)</code></li>
    <li>Физическое адресное пространство — <b>одномерное и непрерывное</b>.</li>
  </ul>
  <img src="https://i.imgur.com/4pR6vEF.png" style="max-width: 80%;">
</div>

<!-- СЛАЙД 17: Страничная организация -->
<div class="slide center">
  <h3>Страничная организация памяти</h3>
  <img src="https://i.imgur.com/5qS7wGH.png" style="max-width: 90%;">
  <p><b>Логический адрес</b> = Npage * size + offset</p>
  <p><b>Физический адрес</b> = Nframe * size + offset</p>
  <p>Свойственна <b>внутренняя фрагментация</b>, но <b>существенно ниже</b>, чем с фиксированными разделами.</p>
</div>

<!-- СЛАЙД 18: Сегментно-страничная -->
<div class="slide center">
  <h3>Сегментно-страничная организация памяти</h3>
  <img src="https://i.imgur.com/6rT8xIJ.png" style="max-width: 90%;">
  <p>Логический адрес: <code>(Nseg, Npage, offset)</code></p>
</div>

<!-- СЛАЙД 19: Многоуровневая таблица -->
<div class="slide">
  <h3>Многоуровневая таблица страниц</h3>
  <ul>
    <li>Таблица страниц процесса располагается в <b>физическом адресном пространстве</b>.</li>
    <li>При больших размерах таблицы страниц её размещение в последовательных кадрах памяти становится проблематично.</li>
    <li>В этом случае таблицу страниц процесса <b>разбиваем на страницы</b> и размещаем по кадрам.</li>
    <li>Строим <b>таблицу страниц для таблицы страниц</b> – <b>двухуровневая таблица страниц</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 20: TLB -->
<div class="slide center">
  <h3>Ассоциативная память (TLB)</h3>
  <img src="https://i.imgur.com/7sU9yKL.png" style="max-width: 80%;">
  <p>Очень дорогая, но <b>крайне быстрая</b>. Хранит <code>page → frame</code>.</p>
</div>

<!-- СЛАЙД 21: Виртуальная память -->
<div class="slide center">
  <h2>ВИРТУАЛЬНАЯ ПАМЯТЬ</h2>
  <img src="https://i.imgur.com/8tV0zMN.png" style="max-width: 70%;">
</div>

ᅠ长闩 廾闩, [07.11.2025 22:49]
<!-- СЛАЙД 22: Концепция -->
<div class="slide">
  <h3>Концепция виртуальной памяти</h3>
  <ul>
    <li>Логическое адресное пространство процесса разбито на участки и <b>линейно кусочно-непрерывно</b> отображается на физическое.</li>
    <li>Связывание адресов происходит на <b>этапе выполнения</b>.</li>
    <li>В оперативной физической памяти одновременно размещаются <b>не все участки</b>, а только их часть, остальные — во <b>вторичной памяти</b>.</li>
    <li>При обращении к участку, находящемуся во вторичной памяти, он <b>подкачивается в оперативную память</b>, возможно с выталкиванием.</li>
  </ul>
</div>

<!-- СЛАЙД 23: Преимущества -->
<div class="slide">
  <h3>Преимущества виртуальной памяти</h3>
  <ul>
    <li>Процесс <b>не ограничен объёмом физической памяти</b>. Упрощается разработка программ.</li>
    <li><b>Повышается степень мультипрограммирования</b>.</li>
    <li>Выгрузка во вторичную память части процесса происходит <b>быстрее</b>, чем выгрузка всего процесса.</li>
    <li>Однако при работе виртуальная память обращается ко вторичной, <b>замедляя работу программ</b>.</li>
    <li><b>Не используется в системах реального времени</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 24: Page fault -->
<div class="slide">
  <h3>Исключительная ситуация: Page fault</h3>
  <p>В случае, когда требуемой страницы нет в оперативной памяти, <b>бит наличия=0</b>, возникает <b>Page fault</b>:</p>
  <ol>
    <li>Выполнение команды прекращается на уровне <b>hardware</b>.</li>
    <li>Сохраняется часть контекста. Управление передаётся по заранее определённому адресу – <b>hardware</b>.</li>
    <li>Сохраняется оставшийся контекст – <b>software</b>.</li>
    <li>Страница подкачивается в память, возможно с выталкиванием – <b>software + hardware</b>.</li>
    <li>Восстановление контекста. Повторное выполнение команды – <b>software + hardware</b>.</li>
  </ol>
</div>

<!-- СЛАЙД 25: Стратегии -->
<div class="slide">
  <h3>Стратегии управления</h3>
  <table>
    <tr><th>Стратегия</th><th>Варианты</th></tr>
    <tr><td><b>Выборка</b></td><td>по запросу, с упреждением</td></tr>
    <tr><td><b>Размещение</b></td><td>первый свободный, first-fit, best-fit, worst-fit</td></tr>
    <tr><td><b>Замещение</b></td><td>?</td></tr>
  </table>
</div>

<!-- СЛАЙД 26: Алгоритмы замещения -->
<div class="slide">
  <h3>Алгоритмы замещения страниц</h3>
  <ul>
    <li><b>Локальные</b>: процессу выделяется определённое количество кадров памяти.</li>
    <li><b>Глобальные</b>: можно использовать кадры других процессов.</li>
    <li>Для анализа используется <b>строка обращений к памяти</b>.</li>
  </ul>
</div>

<!-- СЛАЙД 27: FIFO и Belady -->
<div class="slide">
  <h3>Локальные алгоритмы</h3>
  <ul>
    <li><b>FIFO</b>: Может возникнуть <b>аномалия Belady</b> – при увеличении кадров растёт число page fault.</li>
    <li><b>Стековые алгоритмы</b> не проявляют аномалии Belady:
      <ul>
        <li><b>OPT</b>: вытесняет страницу, к которой дольше не будет обращения (нереализуем).</li>
        <li><b>LRU</b>: вытесняет давно не использованную.</li>
        <li><b>NFU</b>: реже всего использованную.</li>
        <li><b>Второй шанс</b>: если страница недавно пришла, даётся второй шанс.</li>
      </ul>
    </li>
  </ul>
</div>

<!-- СЛАЙД 28: Трешинг -->
<div class="slide">
  <h3>Глобальные алгоритмы</h3>
  <h4>Трешинг (Thrashing)</h4>
  <ul>
    <li>Время на подкачку/откачку > выполнение команд.</li>
    <li>Лавинообразное падение % использования CPU при росте мультипрограммирования.</li>
    <li>Локальное замещение → не влияет на всю ОС.</li>
  </ul>
  <h4>Алгоритм границ</h4>
  <ul>
    <li><b>Верхняя граница</b>: частота page fault > критической → увеличить кадры.</li>
    <li><b>Нижняя граница</b>: рост кадров не даёт прироста → уменьшить кадры.</li>
  </ul>
</div>

<!-- СЛАЙД 29: Спасибо -->
<div class="slide center">
  <h1 style="color: #00d4ff;">Спасибо за внимание!</h1>
  <p style="font-size: 1.5em; margin-top: 30px;">#5 Подсистема управления памятью</p>
</div>

<div class="footer">© 2025 | Операционные системы</div>
</body>
</html>
